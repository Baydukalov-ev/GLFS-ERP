
#Если Сервер Или ТолстыйКлиентОбычноеПриложение Или ВнешнееСоединение Тогда

#Область ОбработчикиСобытий

&После("ПередЗаписью")
Процедура бг_ПередЗаписью(Отказ, РежимЗаписи, РежимПроведения)

	Если ОбменДанными.Загрузка Тогда
		Возврат;
	КонецЕсли;
	
	ИнициализироватьДополнительныеСвойства(РежимЗаписи);
	ПроверитьЗаполнениеБазовыхРеквизитов(Отказ);
	
КонецПроцедуры

&После("ПриЗаписи")
Процедура бг_ПриЗаписи(Отказ)
	
	Если ОбменДанными.Загрузка Тогда
		Возврат;
	КонецЕсли;
	
	Если ДополнительныеСвойства.РежимЗаписи = РежимЗаписиДокумента.Запись Тогда
		
		ОбновитьСтатусДокумента(
			Перечисления.бг_СтатусыДокументовИнтеграцииСоСкладскимиСистемами.ЗагруженБезОбработки,
			Отказ);
			
	КонецЕсли;
	
КонецПроцедуры

&После("ОбработкаПроведения")
Процедура бг_ОбработкаПроведения(Отказ, РежимПроведения)
	
	СнятьСПроведенияОтражениеФактаПоРасходномуОрдеру(Отказ);
	СформироватьДвиженияПоМаркам(Отказ);
	ПровестиОтражениеФактаПоРасходномуОрдеру(Отказ);
	
	ДополнительныеСвойства.Вставить("ДатаОкончанияОбработки", ТекущаяДатаСеанса());
	
	ОбновитьСтатусДокумента(
		Перечисления.бг_СтатусыДокументовИнтеграцииСоСкладскимиСистемами.ЗагруженИОбработан,
		Отказ);
		
	Если Не ЗначениеЗаполнено(ОтражениеФактаПоРасходномуОрдеру) Тогда
		РегистрыСведений.бг_ОбъектыДляОтложеннойОбработки.ДобавитьОбъект(
			Ссылка,
			Перечисления.бг_ВариантыОтложеннойОбработкиОбъектов.РассчитатьПоказателиРаботыОператоровWMS);
	КонецЕсли;
	
КонецПроцедуры

&После("ОбработкаУдаленияПроведения")
Процедура бг_ОбработкаУдаленияПроведения(Отказ)
	
	ОбновитьСтатусДокумента(
		Перечисления.бг_СтатусыДокументовИнтеграцииСоСкладскимиСистемами.ЗагруженБезОбработки,
		Отказ);
		
КонецПроцедуры

#КонецОбласти

#Область СлужебныеПроцедурыИФункции

Процедура ИнициализироватьДополнительныеСвойства(РежимЗаписи)
	
	ДополнительныеСвойства.Вставить("РежимЗаписи", РежимЗаписи);
	ДополнительныеСвойства.Вставить("ДатаНачалаОбработки", ТекущаяДатаСеанса());
	ДополнительныеСвойства.Вставить(
		"ПроводитьПриНаличииОшибок",
		бг_КонстантыПовтИсп.ЗначениеКонстанты("ПереупаковкаПроводитьПриНаличииОшибок"));
		
КонецПроцедуры

Процедура ПроверитьЗаполнениеБазовыхРеквизитов(Отказ)
	
	Если Не ЗначениеЗаполнено(Организация) Тогда
		ОбщегоНазначения.СообщитьПользователю(
			НСтр("ru='Не заполнена организация, проведение невозможно.'"),
			Ссылка,
			"Организация",
			, // ПутьКДанным
			Отказ);
	КонецЕсли;
	
	Если Не ЗначениеЗаполнено(Склад) Тогда
		ОбщегоНазначения.СообщитьПользователю(
			НСтр("ru='Не заполнен склад, проведение невозможно.'"),
			Ссылка,
			"Склад",
			, // ПутьКДанным
			Отказ);
	КонецЕсли;
	
КонецПроцедуры

Процедура ОбновитьСтатусДокумента(Статус, Отказ)

	Если Отказ Тогда
		Возврат;
	КонецЕсли;
	
	РегистрыСведений.бг_ДокументыИнтеграцииСоСкладскимиСистемами.ОбновитьСтатусДокумента(
		Ссылка,
		ТекущаяДатаСеанса(),
		Статус,
		бг_WMS.ВремяОбработки(ДополнительныеСвойства));

КонецПроцедуры

Процедура СообщитьОшибкуПоСтрокеШтрихкодов(ТекстОшибки, ИмяТаблицы, СтрокаТЧ, ИмяПоля, Отказ)
	
	Поле = СтрШаблон(
		"%1[%2].%3",
		ИмяТаблицы,
		Формат(Штрихкоды.Индекс(СтрокаТЧ), "ЧГ=0"),
		ИмяПоля);
	
	Если ДополнительныеСвойства.ПроводитьПриНаличииОшибок Тогда
		ОбщегоНазначения.СообщитьПользователю(ТекстОшибки, Ссылка, Поле, "Объект");
	Иначе
		ОбщегоНазначения.СообщитьПользователю(ТекстОшибки, Ссылка, Поле, "Объект", Отказ);
	КонецЕсли;
		
КонецПроцедуры

Процедура СообщитьОшибкуПользователю(ТекстОшибки, Отказ)
	
	Если ДополнительныеСвойства.ПроводитьПриНаличииОшибок Тогда
		ОбщегоНазначения.СообщитьПользователю(ТекстОшибки);
	Иначе
		ОбщегоНазначения.СообщитьПользователю(ТекстОшибки,,,, Отказ);
	КонецЕсли;
	
КонецПроцедуры

#Область ДвиженияПоМаркам

Процедура СформироватьДвиженияПоМаркам(Отказ)
	
	Если Отказ Тогда
		Возврат;
	КонецЕсли;
	
	ОчиститьДвиженияДокумента();
	
	ТекущиеДанныеШтрихкодов = ТекущиеДанныеШтрихкодов();
	
	Если ПолнаяРазагрегация И Разагрегации.Количество() > 0 Тогда
		ПроверитьСогласованностьТабличныхЧастейПриПолнойРазагрегации(Отказ, ТекущиеДанныеШтрихкодов);
		Если Отказ Тогда
			Возврат;
		КонецЕсли;
	КонецЕсли;
	
	ОтразитьДвиженияПоМаркамССопутствующимиПроверками(ТекущиеДанныеШтрихкодов, Отказ);
	
	Движения.бг_ДвижениеМарок.Записать();
	Движения.бг_СоставУпаковок.Записать();
	
КонецПроцедуры

Процедура ОчиститьДвиженияДокумента()

	ОчиститьДвиженияРегистраБезРегистрацииСообщения(Движения.бг_ДвижениеМарок);
	ОчиститьДвиженияРегистраБезРегистрацииСообщения(Движения.бг_СоставУпаковок);

КонецПроцедуры

Процедура ПроверитьСогласованностьТабличныхЧастейПриПолнойРазагрегации(Отказ, ТекущиеДанныеШтрихкодов)
	
	ДатаПолученияШтрихкодов = бг_МаркируемаяПродукция.ДатаПолученияШтрихкодов(ЭтотОбъект, Ложь);
	
	// Разузловываем упаковки, указанные на вкладке "Разагрегации" до штрихкодов по данным ERP, с целью проверить,
	// что все эти марки и упаковки лишаются родителя на вкладке "Штрихкоды".
	ТоварыПоШтрихкодам = бг_МаркируемаяПродукция.ДанныеМарокПоШтрихкодам(
		Разагрегации.Выгрузить().ВыгрузитьКолонку("Штрихкод"),
		Документы.битПереупаковка.ОрганизацияЕГАИСДокумента(Ссылка),
		Неопределено,
		ДатаПолученияШтрихкодов);
		
	ПроверяемыеПоля = "Штрихкод, ШтрихкодРодитель";
	РазагрегируемыеМарки = ТоварыПоШтрихкодам.Скопировать(, ПроверяемыеПоля);
	РазагрегируемыеМарки.Свернуть(ПроверяемыеПоля);
	
	Для каждого СтрокаРазагрегируемыеМарки Из РазагрегируемыеМарки Цикл
		
		// Проверка бутылки.
		ТипУпаковки = бг_МаркируемаяПродукцияКлиентСервер.ТипУпаковкиШтрихкода(СтрокаРазагрегируемыеМарки.Штрихкод);
		
		Если ТипУпаковки <> Перечисления.бг_ТипыЕдиницИзмерения.Бутылка Тогда
			ТекстОшибки = СтрШаблон(НСтр("ru='Тип штрихкода %1 не является бутылкой.'"), СтрокаРазагрегируемыеМарки.Штрихкод);
			СообщитьОшибкуПользователю(ТекстОшибки, Отказ);
		КонецЕсли;
		
		Если Не ШтрихкодОчищаетсяВТабличнойЧастиШтрихкодов(СтрокаРазагрегируемыеМарки.Штрихкод) Тогда
			
			ТекстОшибки = СтрШаблон(
				НСтр("ru='Штрихкод %1 содержится в разагрегируемых упаковках,
				| но по нему не очищается родитель на вкладке ""Штрихкоды"".'"),
				СтрокаРазагрегируемыеМарки.Штрихкод);
				
			СообщитьОшибкуПользователю(ТекстОшибки, Отказ);
		КонецЕсли;
		
		// Проверки коробки, если есть.
		Если ЗначениеЗаполнено(СтрокаРазагрегируемыеМарки.ШтрихкодРодитель) Тогда
			
			ТипУпаковки = бг_МаркируемаяПродукцияКлиентСервер.ТипУпаковкиШтрихкода(СтрокаРазагрегируемыеМарки.ШтрихкодРодитель);
			
			Если Не ЗначениеЗаполнено(ТипУпаковки) Тогда
				ТекстОшибки = СтрШаблон(
					НСтр("ru='Неизвестный тип штрихкода %1.'"),
					СтрокаРазагрегируемыеМарки.ШтрихкодРодитель);
					
				СообщитьОшибкуПользователю(ТекстОшибки, Отказ);
				Продолжить;
			КонецЕсли;
			
			Если ТипУпаковки <> Перечисления.бг_ТипыЕдиницИзмерения.Коробка Тогда
				Продолжить;
			КонецЕсли;
			
			ПараметрыПоискаТекущихДанныхШтрихкода = Новый Структура("Штрихкод", СтрокаРазагрегируемыеМарки.ШтрихкодРодитель);
			
			НайденныеСтрокиТекущихДанныхШтрихкода = ТекущиеДанныеШтрихкодов.Упаковки.НайтиСтроки(
				ПараметрыПоискаТекущихДанныхШтрихкода);
			
			Если НайденныеСтрокиТекущихДанныхШтрихкода.Количество() > 0
				И ЗначениеЗаполнено(НайденныеСтрокиТекущихДанныхШтрихкода[0].ШтрихкодРодитель)
				И Разагрегации.Найти(СтрокаРазагрегируемыеМарки.ШтрихкодРодитель, "Штрихкод") = Неопределено
				И Разагрегации.Найти(НайденныеСтрокиТекущихДанныхШтрихкода[0].ШтрихкодРодитель, "Штрихкод") <> Неопределено Тогда
				
				// У коробки был родитель (паллета), при полной разагрегации, если разагрегируется целиком паллета,
				// она указана в ТЧ "Разагрегации", и сама коробка не указана в ТЧ "Разагрегации" - эта коробка должна
				// лишаться родителя на вкладке "Штрихкоды".
				ДанныеПредыдущегоСостоянияШтрихкода = НайденныеСтрокиТекущихДанныхШтрихкода[0];
				
				Если Не ШтрихкодОчищаетсяВТабличнойЧастиШтрихкодов(СтрокаРазагрегируемыеМарки.ШтрихкодРодитель) Тогда
					
					ТекстОшибки = СтрШаблон(
						НСтр("ru='Коробка %1 является родителем разагрегируемых марок, при полной разагрегации она также должна
						| очищаться на вкладке ""Штрихкоды"".'"),
						СтрокаРазагрегируемыеМарки.ШтрихкодРодитель);
						
						СообщитьОшибкуПользователю(ТекстОшибки, Отказ);
				КонецЕсли;
			КонецЕсли;
		КонецЕсли;
	КонецЦикла;

КонецПроцедуры

Функция ШтрихкодОчищаетсяВТабличнойЧастиШтрихкодов(Штрихкод)

	ПараметрыПоиска = Новый Структура("Штрихкод", Штрихкод);
	НайденныеСтроки = Штрихкоды.НайтиСтроки(ПараметрыПоиска);
	
	Возврат НайденныеСтроки.Количество() > 0 И ПустаяСтрока(НайденныеСтроки[0].ШтрихкодРодитель);

КонецФункции

Процедура ОтразитьДвиженияПоМаркамССопутствующимиПроверками(ТекущиеДанныеШтрихкодов, Отказ)
	
	ТекущиеДанныеШтрихкодов.Марки.Индексы.Добавить("Штрихкод");
	ТекущиеДанныеШтрихкодов.Упаковки.Индексы.Добавить("Штрихкод, ШтрихкодРодитель");
	
	Для каждого СтрокаШтрихкоды Из Штрихкоды Цикл
		
		// 1. Проверка валидности типов штрихкодов.
		ТипУпаковки = бг_МаркируемаяПродукцияКлиентСервер.ТипУпаковкиШтрихкода(СтрокаШтрихкоды.Штрихкод);
		
		Если Не ЗначениеЗаполнено(ТипУпаковки) Тогда
			ТекстОшибки = СтрШаблон(НСтр("ru='Неизвестный тип штрихкода %1'"), СтрокаШтрихкоды.Штрихкод);
			ОбщегоНазначения.СообщитьПользователю(ТекстОшибки, Ссылка, "Штрихкоды", "Объект", Отказ);
			Продолжить;
		КонецЕсли;
		
		Если ЗначениеЗаполнено(СтрокаШтрихкоды.ШтрихкодРодитель) Тогда
			
			ТипУпаковкиРодителя = бг_МаркируемаяПродукцияКлиентСервер.ТипУпаковкиШтрихкода(СтрокаШтрихкоды.ШтрихкодРодитель);
			
			Если Не ЗначениеЗаполнено(ТипУпаковкиРодителя) Тогда
				ТекстОшибки = СтрШаблон(НСтр("ru='Неизвестный тип штрихкода родителя %1'"), СтрокаШтрихкоды.ШтрихкодРодитель);
				ОбщегоНазначения.СообщитьПользователю(ТекстОшибки, Ссылка, "Штрихкоды", "Объект", Отказ);
				Продолжить;
			КонецЕсли;
		КонецЕсли;
		
		// 2. В зависимости от типа штрихкода (марка или упаковка) необходимо формировать движения в соотв. регистр:
		//  бг_ДвижениеМарок или бг_СоставУпаковок.
		Если ТипУпаковки = Перечисления.бг_ТипыЕдиницИзмерения.Бутылка Тогда
			
			// 3. Проверки для марок (бутылок):
			//  3.1. Найдено предыдущее состояние марки - переупаковываться могут существующие марки с определенными статусами.
			//  У марки меняется упаковка, но серия и статус должны остаться прежними, из регистра.
			ПараметрыПоискаТекущихДанныхШтрихкода = Новый Структура("Штрихкод", СтрокаШтрихкоды.Штрихкод);
			НайденныеСтрокиТекущихДанныхШтрихкода = ТекущиеДанныеШтрихкодов.Марки.НайтиСтроки(ПараметрыПоискаТекущихДанныхШтрихкода);
			
			Если НайденныеСтрокиТекущихДанныхШтрихкода.Количество() > 0 Тогда
				
				ДанныеПредыдущегоСостоянияМарки = НайденныеСтрокиТекущихДанныхШтрихкода[0];
				
				// 3.2. Очищение родителя (изъятие или разагрегация):
				Если Не ЗначениеЗаполнено(СтрокаШтрихкоды.ШтрихкодРодитель) Тогда
					
					Если Не ЗначениеЗаполнено(ДанныеПредыдущегоСостоянияМарки.ШтрихкодРодитель) Тогда
						
						// 3.2.1. Может происходить только если ранее родитель был.
						ТекстОшибки = СтрШаблон(
							НСтр("ru='Попытка разагрегации/изъятия марки %1, которая ранее числилась без упаковки'"),
							СтрокаШтрихкоды.Штрихкод);
							
						СообщитьОшибкуПоСтрокеШтрихкодов(ТекстОшибки, "Штрихкоды", СтрокаШтрихкоды, "Штрихкод", Отказ);
						Если Не ДополнительныеСвойства.ПроводитьПриНаличииОшибок Тогда
							Продолжить;
						КонецЕсли;
					КонецЕсли;
					
					ПараметрыПоискаИзъятия = Новый Структура("Штрихкод", СтрокаШтрихкоды.Штрихкод);
					НайденныеСтрокиИзъятия = Изъятия.НайтиСтроки(ПараметрыПоискаИзъятия);
					
					ПараметрыПоискаРазагрегацииПервыйУровеньРодителей = Новый Структура(
						"Штрихкод",
						ДанныеПредыдущегоСостоянияМарки.ШтрихкодРодитель);
						
					НайденныеСтрокиРазагрегацииПервыйУровеньРодителей = Разагрегации.НайтиСтроки(
						ПараметрыПоискаРазагрегацииПервыйУровеньРодителей);
						
					Если ПолнаяРазагрегация Тогда
						
						Если ЗначениеЗаполнено(ДанныеПредыдущегоСостоянияМарки.ШтрихкодРодительВторойУровень) Тогда
							// При полной разагрегации на вкладке "Разагрегации" может быть указана разагрегируемая паллета,
							// при этом коробки дополнительно нигде не указываются.
							ПараметрыПоискаРазагрегацииВторойУровеньРодителей = Новый Структура(
								"Штрихкод",
								ДанныеПредыдущегоСостоянияМарки.ШтрихкодРодительВторойУровень);
								
							НайденныеСтрокиРазагрегацииВторойУровеньРодителей = Разагрегации.НайтиСтроки(
								ПараметрыПоискаРазагрегацииВторойУровеньРодителей);
							
							Если НайденныеСтрокиИзъятия.Количество() = 0
								И НайденныеСтрокиРазагрегацииПервыйУровеньРодителей.Количество() = 0
								И НайденныеСтрокиРазагрегацииВторойУровеньРодителей.Количество() = 0 Тогда
								
								// 3.2.1. При этом марка должна содержаться в ТЧ "Изъятия", или предыдущий родитель
								//  должен содержаться на вкладке "Разагрегации", или вышестоящий родитель должен
								//  содержаться на вкладке "Разагрегации".
								ТекстОшибки = СтрШаблон(
									НСтр("ru='Нет данных по изымаемой марке %1 на вкладке ""Изъятия"",
									| также нет данных о разагрегации ее предыдущего родителя %2 на вкладке ""Разагрегация"",
									| также нет данных о разагрегации ее предыдущего вышестоящего родителя %3 на вкладке ""Разагрегация""'"),
									СтрокаШтрихкоды.Штрихкод,
									ДанныеПредыдущегоСостоянияМарки.ШтрихкодРодитель,
									ДанныеПредыдущегоСостоянияМарки.ШтрихкодРодительВторойУровень);
									
								СообщитьОшибкуПоСтрокеШтрихкодов(ТекстОшибки, "Штрихкоды", СтрокаШтрихкоды, "Штрихкод", Отказ);
								Если Не ДополнительныеСвойства.ПроводитьПриНаличииОшибок Тогда
									Продолжить;
								КонецЕсли;
							КонецЕсли;
						КонецЕсли;
						
					Иначе
						
						Если НайденныеСтрокиИзъятия.Количество() = 0
							И НайденныеСтрокиРазагрегацииПервыйУровеньРодителей.Количество() = 0 Тогда
							
							// 3.2.1. При этом марка должна содержаться в ТЧ "Изъятия", или предыдущий родитель
							//  должен содержаться на вкладке "Разагрегации".
							ТекстОшибки = СтрШаблон(
								НСтр("ru='Нет данных по изымаемой марке %1 на вкладке ""Изъятия"",
								| также нет данных о разагрегации ее предыдущего родителя %2 на вкладке ""Разагрегация""'"),
								СтрокаШтрихкоды.Штрихкод,
								ДанныеПредыдущегоСостоянияМарки.ШтрихкодРодитель);
								
							СообщитьОшибкуПоСтрокеШтрихкодов(ТекстОшибки, "Штрихкоды", СтрокаШтрихкоды, "Штрихкод", Отказ);
							Если Не ДополнительныеСвойства.ПроводитьПриНаличииОшибок Тогда
								Продолжить;
							КонецЕсли;
						КонецЕсли;
					КонецЕсли;
					
				Иначе
					// 3.3. Агрегация.
					Если ЗначениеЗаполнено(ДанныеПредыдущегоСостоянияМарки.ШтрихкодРодитель)
						И ЗначениеЗаполнено(СтрокаШтрихкоды.ШтрихкодРодитель)
						И ДанныеПредыдущегоСостоянияМарки.ШтрихкодРодитель = СтрокаШтрихкоды.ШтрихкодРодитель Тогда
						
						// 3.3.1. Родитель должен смениться.
						ТекстОшибки = СтрШаблон(
							НСтр("ru='Попытка агрегации марки %1, которая ранее числилась за тем же родителем.'"),
							СтрокаШтрихкоды.Штрихкод);
							
						СообщитьОшибкуПоСтрокеШтрихкодов(ТекстОшибки, "Штрихкоды", СтрокаШтрихкоды, "Штрихкод", Отказ);
						Если Не ДополнительныеСвойства.ПроводитьПриНаличииОшибок Тогда
							Продолжить;
						КонецЕсли;
					КонецЕсли;
					
					ПараметрыПоискаАгрегации = Новый Структура("Штрихкод", СтрокаШтрихкоды.Штрихкод);
					НайденныеСтрокиАгрегации = Агрегации.НайтиСтроки(ПараметрыПоискаАгрегации);
					
					Если НайденныеСтрокиАгрегации.Количество() = 0 Тогда
						
						// 3.3.2. При этом марка должна содержаться в ТЧ "Агрегации".
						ТекстОшибки = СтрШаблон(
							НСтр("ru='Нет данных по агрегируемой марке %1 на вкладке ""Агрегации""'"),
							СтрокаШтрихкоды.Штрихкод);
							
						СообщитьОшибкуПоСтрокеШтрихкодов(ТекстОшибки, "Штрихкоды", СтрокаШтрихкоды, "Штрихкод", Отказ);
						Если Не ДополнительныеСвойства.ПроводитьПриНаличииОшибок Тогда
							Продолжить;
						КонецЕсли;
					КонецЕсли;
				КонецЕсли;
				
				Запись = Движения.бг_ДвижениеМарок.Добавить();
				Запись.Период = Дата;
				ЗаполнитьЗначенияСвойств(Запись, ДанныеПредыдущегоСостоянияМарки, "Серия, СтатусМарки, ГУИДМарки");
				Запись.КодУпаковки = СтрокаШтрихкоды.ШтрихкодРодитель;
				
			Иначе
				
				ТекстОшибки = СтрШаблон(
					НСтр("ru='Не найден предыдущий статус марки %1'"),
					СтрокаШтрихкоды.Штрихкод);
					
				СообщитьОшибкуПоСтрокеШтрихкодов(ТекстОшибки, "Штрихкоды", СтрокаШтрихкоды, "Штрихкод", Отказ);
				Если Не ДополнительныеСвойства.ПроводитьПриНаличииОшибок Тогда
					Продолжить;
				КонецЕсли;
			КонецЕсли;
			
		Иначе
			
			// 4. Проверки для упаковок (коробок и паллет):
			Если Не ЗначениеЗаполнено(СтрокаШтрихкоды.ШтрихкодРодитель) Тогда
				
				//  4.1. Очищение родителя (изъятие или разагрегация):
				ПараметрыПоискаТекущихДанныхШтрихкода = Новый Структура("Штрихкод", СтрокаШтрихкоды.Штрихкод);
				
				НайденныеСтрокиТекущихДанныхШтрихкода = ТекущиеДанныеШтрихкодов.Упаковки.НайтиСтроки(
					ПараметрыПоискаТекущихДанныхШтрихкода);
				
				Если НайденныеСтрокиТекущихДанныхШтрихкода.Количество() = 0
					Или Не ЗначениеЗаполнено(НайденныеСтрокиТекущихДанныхШтрихкода[0].ШтрихкодРодитель) Тогда
					
					// 4.1.1. Может происходить только если ранее родитель был.
					ТекстОшибки = СтрШаблон(
						НСтр("ru='Попытка разагрегации/изъятия упаковки %1, которая ранее числилась без родительской упаковки'"),
						СтрокаШтрихкоды.Штрихкод);
						
					СообщитьОшибкуПоСтрокеШтрихкодов(ТекстОшибки, "Штрихкоды", СтрокаШтрихкоды, "Штрихкод", Отказ);
					Если Не ДополнительныеСвойства.ПроводитьПриНаличииОшибок Тогда
						Продолжить;
					КонецЕсли;
					
				Иначе
					
					ДанныеПредыдущегоСостоянияШтрихкода = НайденныеСтрокиТекущихДанныхШтрихкода[0];
					
					ПараметрыПоискаИзъятия = Новый Структура("Штрихкод", СтрокаШтрихкоды.Штрихкод);
					НайденныеСтрокиИзъятия = Изъятия.НайтиСтроки(ПараметрыПоискаИзъятия);
					
					ПараметрыПоискаРазагрегации = Новый Структура(
						"Штрихкод",
						ДанныеПредыдущегоСостоянияШтрихкода.ШтрихкодРодитель);
						
					НайденныеСтрокиРазагрегации = Разагрегации.НайтиСтроки(ПараметрыПоискаРазагрегации);
					
					Если НайденныеСтрокиИзъятия.Количество() = 0 И НайденныеСтрокиРазагрегации.Количество() = 0 Тогда
						
						//  4.1.2. При этом упаковка должна содержаться в ТЧ "Изъятия" или предыдущий родитель
						//   должен содержаться на вкладке "Разагрегации".
						ТекстОшибки = СтрШаблон(
							НСтр("ru='Нет данных по изымаемой упаковке %1 на вкладке ""Изъятия"",
							| также нет данных о разагрегации ее предыдущего родителя %2 на вкладке ""Разагрегация""'"),
							СтрокаШтрихкоды.Штрихкод,
							ДанныеПредыдущегоСостоянияШтрихкода.ШтрихкодРодитель);
							
						СообщитьОшибкуПоСтрокеШтрихкодов(ТекстОшибки, "Штрихкоды", СтрокаШтрихкоды, "Штрихкод", Отказ);
						Если Не ДополнительныеСвойства.ПроводитьПриНаличииОшибок Тогда
							Продолжить;
						КонецЕсли;
					КонецЕсли;
				КонецЕсли;
			КонецЕсли;
			
			Запись = Движения.бг_СоставУпаковок.Добавить();
			Запись.Период = Дата;
			Запись.КодУпаковки = СтрокаШтрихкоды.Штрихкод;
			Запись.КодВышестоящейУпаковки = СтрокаШтрихкоды.ШтрихкодРодитель;
		КонецЕсли;
	КонецЦикла;
	
КонецПроцедуры

Функция ТекущиеДанныеШтрихкодов()

	СписокШтрихкодов = Штрихкоды.ВыгрузитьКолонку("Штрихкод");
	
	ШтрихкодыСРодителями = ШтрихкодыРодителиДляПроверкиПроведения();
	ОбщегоНазначенияКлиентСервер.ДополнитьМассив(ШтрихкодыСРодителями, СписокШтрихкодов, Истина);
	
	ДатаПолученияШтрихкодов = бг_МаркируемаяПродукция.ДатаПолученияШтрихкодов(ЭтотОбъект, Ложь);
	
	// Получаем текущие данные марок по штрихкодам.
	СтатусыМарокПоОперации = Перечисления.бг_СтатусыАкцизныхМарок.СтатусыПоОперации(Метаданные().Имя);
	
	ДанныеШтрихкодов = бг_МаркируемаяПродукция.ДанныеМарокПоШтрихкодам(
		СписокШтрихкодов,
		Документы.битПереупаковка.ОрганизацияЕГАИСДокумента(Ссылка),
		СтатусыМарокПоОперации.СтатусыКПереупаковке,
		ДатаПолученияШтрихкодов);
		
	// Получаем текущие данные состава упаковок по штрихкодам, необходимы для получения родителя второго уровня.
	ДанныеСоставаУпаковок = бг_МаркируемаяПродукция.ДанныеСоставаУпаковокСрезПоследних(
		ШтрихкодыСРодителями,
		ДатаПолученияШтрихкодов);
		
	// Заполняем ШтрихкодРодительВторойУровень в ДанныеШтрихкодов.
	ДанныеШтрихкодов.Колонки.Добавить(
		"ШтрихкодРодительВторойУровень",
		ОбщегоНазначения.ОписаниеТипаСтрока(
			бг_МаркируемаяПродукция.ДлиныШтрихкодовМарок().Упаковка));
			
	ДанныеСоставаУпаковок.Индексы.Добавить("Штрихкод");
	
	Для каждого ДанныеШтрихкода Из ДанныеШтрихкодов Цикл
		
		Если Не ЗначениеЗаполнено(ДанныеШтрихкода.ШтрихкодРодитель) Тогда
			Продолжить;
		КонецЕсли;
		
		ПараметрыПоиска = Новый Структура("Штрихкод", ДанныеШтрихкода.ШтрихкодРодитель);	
		НайденныеСтроки = ДанныеСоставаУпаковок.НайтиСтроки(ПараметрыПоиска);
		
		Если НайденныеСтроки.Количество() > 1 Тогда
			ДанныеШтрихкода.ШтрихкодРодительВторойУровень = НайденныеСтроки[0].ШтрихкодРодитель;
		КонецЕсли;
	КонецЦикла;
	
	// Заполняем результативные данные.
	ТекущиеДанныеШтрихкодов = Новый Структура;
	ТекущиеДанныеШтрихкодов.Вставить("Марки", ДанныеШтрихкодов);
	ТекущиеДанныеШтрихкодов.Вставить("Упаковки", ДанныеСоставаУпаковок);
		
	Возврат ТекущиеДанныеШтрихкодов;
	
КонецФункции

Функция ШтрихкодыРодителиДляПроверкиПроведения()
	
	ШтрихкодыРодители = Новый Массив;
	
	Для каждого СтрокаШтрихкоды Из Штрихкоды Цикл
		Если Не ПустаяСтрока(СтрокаШтрихкоды.ШтрихкодРодитель) Тогда
			ШтрихкодыРодители.Добавить(СтрокаШтрихкоды.ШтрихкодРодитель);
		КонецЕсли;
	КонецЦикла;
	
	Для каждого СтрокаИзъятия Из Изъятия Цикл
		ТипУпаковки = бг_МаркируемаяПродукцияКлиентСервер.ТипУпаковкиШтрихкода(СтрокаИзъятия.Штрихкод);
		Если ТипУпаковки = Перечисления.бг_ТипыЕдиницИзмерения.Коробка
			Или ТипУпаковки = Перечисления.бг_ТипыЕдиницИзмерения.Паллета Тогда
			
			Если ШтрихкодыРодители.Найти(СтрокаИзъятия.Штрихкод) = Неопределено Тогда
				ШтрихкодыРодители.Добавить(СтрокаИзъятия.Штрихкод);
			КонецЕсли;
		КонецЕсли;
	КонецЦикла;
	
	Для каждого СтрокаАгрегации Из Агрегации Цикл
		ТипУпаковки = бг_МаркируемаяПродукцияКлиентСервер.ТипУпаковкиШтрихкода(СтрокаАгрегации.Штрихкод);
		Если ТипУпаковки = Перечисления.бг_ТипыЕдиницИзмерения.Коробка
			Или ТипУпаковки = Перечисления.бг_ТипыЕдиницИзмерения.Паллета Тогда
			
			Если ШтрихкодыРодители.Найти(СтрокаАгрегации.Штрихкод) = Неопределено Тогда
				ШтрихкодыРодители.Добавить(СтрокаАгрегации.Штрихкод);
			КонецЕсли;
		КонецЕсли;
		
		ТипУпаковки = бг_МаркируемаяПродукцияКлиентСервер.ТипУпаковкиШтрихкода(СтрокаАгрегации.ШтрихкодРодитель);
		Если ТипУпаковки = Перечисления.бг_ТипыЕдиницИзмерения.Коробка
			Или ТипУпаковки = Перечисления.бг_ТипыЕдиницИзмерения.Паллета Тогда
			
			Если ШтрихкодыРодители.Найти(СтрокаАгрегации.ШтрихкодРодитель) = Неопределено Тогда
				ШтрихкодыРодители.Добавить(СтрокаАгрегации.ШтрихкодРодитель);
			КонецЕсли;
		КонецЕсли;
	КонецЦикла;
	
	Для каждого СтрокаРазагрегации Из Разагрегации Цикл
		ТипУпаковки = бг_МаркируемаяПродукцияКлиентСервер.ТипУпаковкиШтрихкода(СтрокаРазагрегации.Штрихкод);
		Если ТипУпаковки = Перечисления.бг_ТипыЕдиницИзмерения.Коробка
			Или ТипУпаковки = Перечисления.бг_ТипыЕдиницИзмерения.Паллета Тогда
			
			Если ШтрихкодыРодители.Найти(СтрокаРазагрегации.Штрихкод) = Неопределено Тогда
				ШтрихкодыРодители.Добавить(СтрокаРазагрегации.Штрихкод);
			КонецЕсли;
		КонецЕсли;
	КонецЦикла;
	
	Возврат ШтрихкодыРодители;
	
КонецФункции

Процедура ОчиститьДвиженияРегистраБезРегистрацииСообщения(НаборЗаписей)
	
	НаборЗаписей.Очистить();
	НаборЗаписей.ДополнительныеСвойства.Вставить("адаптер_ЭтоЗагрузкаДанных", Истина);
	НаборЗаписей.Записать();
	НаборЗаписей.ДополнительныеСвойства.Удалить("адаптер_ЭтоЗагрузкаДанных");
	
КонецПроцедуры

#КонецОбласти // Конец ДвиженияПоМаркам

#Область ОтражениеФактаПоРасходномуОрдеру

Процедура СнятьСПроведенияОтражениеФактаПоРасходномуОрдеру(Отказ)
	
	Если Отказ
		Или Не ЗначениеЗаполнено(ОтражениеФактаПоРасходномуОрдеру)
		Или Не ОбщегоНазначения.СсылкаСуществует(ОтражениеФактаПоРасходномуОрдеру) Тогда
		
		Возврат;
	КонецЕсли;
	
	Если Не ОбщегоНазначения.ЗначениеРеквизитаОбъекта(ОтражениеФактаПоРасходномуОрдеру, "Проведен") Тогда
		Возврат;
	КонецЕсли;
	
	ОтражениеФактаПоРасходномуОрдеруОбъект = ОтражениеФактаПоРасходномуОрдеру.ПолучитьОбъект();
	
	// Ордер-факт своими движениями может создать ситуацию невозможности проведения переупаковки.
	ОтражениеФактаПоРасходномуОрдеруОбъект.Заблокировать();
	ОтражениеФактаПоРасходномуОрдеруОбъект.Записать(РежимЗаписиДокумента.ОтменаПроведения);
	
КонецПроцедуры

Процедура ПровестиОтражениеФактаПоРасходномуОрдеру(Отказ)
	
	Перем адаптер_РаботаСДаннымиИБ;
	адаптер_РаботаСДаннымиИБ = ОбщегоНазначения.ОбщийМодуль("адаптер_РаботаСДаннымиИБ");
	
	Если Отказ
		Или Не ЗначениеЗаполнено(ОтражениеФактаПоРасходномуОрдеру)
		Или Не адаптер_РаботаСДаннымиИБ.СсылкаСуществует(ОтражениеФактаПоРасходномуОрдеру) Тогда
		
		Возврат;
	КонецЕсли;
	
	ОтражениеФактаПоРасходномуОрдеруОбъект = ОтражениеФактаПоРасходномуОрдеру.ПолучитьОбъект();
	
	// Ордер-факт и переупаковка могут прилететь почти одновременно, и ордер-факт может уже записываться.
	ОтражениеФактаПоРасходномуОрдеруОбъект.Заблокировать();
	
	// Движения ОтражениеФактаПоРасходномуОрдеруОбъект строятся на движениях данного документа,
	//  поэтому дата должна быть выше.
	ОтражениеФактаПоРасходномуОрдеруОбъект.Дата = Дата + 1; 
	ОтражениеФактаПоРасходномуОрдеруОбъект.Записать(РежимЗаписиДокумента.Проведение);

КонецПроцедуры

#КонецОбласти // Конец ОтражениеФактаПоРасходномуОрдеру

#КонецОбласти

#КонецЕсли
